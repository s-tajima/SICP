;= Question =============================================================================
;
; 問題 4.7
;  
; let*の変数の束縛は左から右へ順に行われ, 
; 各束縛は先行する束縛のすべてが見える環境で行われる他はlet*はletと同じである. 
; 例えば
; 
; (let* ((x 3)
;        (y (+ x 2))
;        (z (+ x y 5)))
;       (* x z))
;
; は39を返す. 
;
; let*式がどのように入れ子のlet式に書き直せるかを説明し, 
; この変換を行う手続きlet*->nested-lets を書け. 
;
; letの実装が済んでいて(問題4.6), 
; 評価器がlet*も処理出来るように拡張したければ, 
; evalにその行動が
;
; (eval (let*->nested-lets exp) env)
;
; である節を追加するだけで十分か, 
; それとも導出されたのでない式を使ってlet*を積極的に展開しなければならないか.
; 
; 
;= Prepared =============================================================================

(load "./eval.scm")

;= Answer ===============================================================================

(print (let* ((x 3)
              (y (+ x 2))
              (z (+ x y 5)))
             (* x z)))


(print 
  (let ((x 3))
    (let ((y (+ x 2)))
      (let ((z (+ x y 5)))
        (* x z)))))

